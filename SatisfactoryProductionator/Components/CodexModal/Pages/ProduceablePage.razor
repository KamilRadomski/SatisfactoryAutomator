@using SatisfactoryProductionator.DataModels.Enums;
@using SatisfactoryProductionator.DataModels.Models.Codex;
@using SatisfactoryProductionator.DataModels.Models;
@using SatisfactoryProductionator.Extensions;
@using SatisfactoryProductionator.Services;

@inject CodexModalState CodexModalState;
@inject CodexState CodexState;

@implements IDisposable

<table class="page-table h-90 w99">
    <tr>
        <td colspan="4" class="page-header w99">@selectedEntry.GetPageHeader().FormatCategoryName() @GetTierDisplay()</td>
    </tr>
    <tr>
        <td>
            @{
                var itemBundle = BundleItems();
            }
            <table class="h-100 w99">
                @foreach (var group in itemBundle)
                {
                    <tr class="flex-even w99">

                        @foreach (var item in group)
                        {
                            <td>
                                <button class="image-button mt-16" type="button" @onclick="@(() => CodexModalState.SetSelectedItem(item))">
                                    <img class="image-96" src=@CodexState.FetchIconPath(item) alt=@item />
                                    <div class="font-16 mt-4">@CodexState.FetchDisplayName(item).FormatDisplayName()</div>
                                </button>
                            </td>
                        }
                    </tr>
                }
            </table>
        </td>
    </tr>
</table>


@code {
    [CascadingParameter(Name = "SelectedEntry")]
    public ModalEntry selectedEntry { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        CodexModalState.OnStateChange += StateHasChanged;
        CodexState.OnStateChange += StateHasChanged;
    }

    public void Dispose()
    {
        CodexModalState.OnStateChange -= StateHasChanged;
        CodexState.OnStateChange -= StateHasChanged;
    }

    private List<List<string>> BundleItems()
    {
        List<List<string>> items = new();

        var tempList = new List<string>();

        var entries = selectedEntry.GetEntries();
        var rowSplit = GetRowSplit(entries.Count);

        foreach (var entry in entries)
        {
            tempList.Add(entry);

            if (tempList.Count % rowSplit == 0)
            {
                items.Add(tempList);
                tempList = new List<string>();
            }
        }

        if (tempList.Count > 0)
        {
            items.Add(tempList);
        }

        return items;
    }

    private int GetRowSplit(int cnt)
    {
        if (cnt <= 4) return 4;

        if (cnt % 2 == 1) cnt++;

        if (cnt % 5 == 0) return 5;
        else if (cnt % 4 == 0) return 4;
        else return 3;
    }

    private string GetTierDisplay()
    {
        if (selectedEntry.CodexEntry.CodexSubItemType is not CodexSubItemType.ElevatorPhases) return "";

        var phase = int.Parse(selectedEntry.CodexEntry.ClassName.Replace("Schematic_Phase_", ""));

        if (phase == 4) return "";

        var index = selectedEntry.Index;
        var tier = ((2 * phase) + index + 1).ToString();

        return $"::Tier {tier}";
    }
}
